/* *********************************************************************** *
 * project: org.matsim.*
 * MATSim4UrbanSim.java
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 * copyright       : (C) 2010 by the members listed in the COPYING,        *
 *                   LICENSE and WARRANTY file.                            *
 * email           : info at matsim dot org                                *
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *   See also COPYING, LICENSE and WARRANTY file                           *
 *                                                                         *
 * *********************************************************************** */

/**
 *
 */
package org.matsim.contrib.matsim4opus.matsim4urbansim;


import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

import org.apache.log4j.Logger;
import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.population.Population;
import org.matsim.contrib.matsim4opus.constants.Constants;
import org.matsim.contrib.matsim4opus.matsim4urbansim.jaxbconfig.MatsimConfigType;
import org.matsim.contrib.matsim4opus.utils.DateUtil;
import org.matsim.contrib.matsim4opus.utils.InitMATSimScenario;
import org.matsim.contrib.matsim4opus.utils.JAXBUnmaschal;
import org.matsim.contrib.matsim4opus.utils.helperObjects.Benchmark;
import org.matsim.contrib.matsim4opus.utils.helperObjects.WorkplaceObject;
import org.matsim.contrib.matsim4opus.utils.io.FileCopy;
import org.matsim.contrib.matsim4opus.utils.io.Paths;
import org.matsim.contrib.matsim4opus.utils.io.ReadFromUrbansimParcelModel;
import org.matsim.core.config.ConfigUtils;
import org.matsim.core.controler.Controler;
import org.matsim.core.facilities.ActivityFacilitiesImpl;
import org.matsim.core.network.NetworkImpl;
import org.matsim.core.network.algorithms.NetworkCleaner;
import org.matsim.core.scenario.ScenarioImpl;
import org.matsim.core.scenario.ScenarioUtils;


/**
 * @author thomas
 *
 */
public class MATSim4UrbanSim {

	// logger
	private static final Logger log = Logger.getLogger(MATSim4UrbanSim.class);

	// MATSim scenario
	ScenarioImpl scenario = null;
	// Benchmarking computation times and hard disc space ... 
	Benchmark benchmark = null;
	// indicates if MATSim run was successful
	static boolean isSuccessfulMATSimRun = Boolean.FALSE;
	
	/**
	 * constructor
	 * 
	 * @param args contains at least a reference to 
	 * 		  MATSim4UrbanSim configuration generated by UrbanSim
	 * 
	 */
	MATSim4UrbanSim(String args[]){
		
		// Stores location of MATSim configuration file
		String matsimConfiFile = (args!= null && args.length>0) ? args[0].trim():null;
		// checks if args parameter contains a valid path
		Paths.isValidPath(matsimConfiFile);

		// get default scenario
		scenario = (ScenarioImpl) ScenarioUtils.createScenario(ConfigUtils.createConfig());
		if( !(new InitMATSimScenario(scenario, matsimConfiFile)).init() ){
			log.error("An error occured while initializing MATSim scenario ...");
			System.exit(-1);
		}			
		ScenarioUtils.loadScenario(scenario);
		
		// init Benchmark as default
		benchmark = new Benchmark();
	}
	
	/**
	 * prepare MATSim for traffic flow simulation ...
	 */
	void runMATSim(){
		log.info("Starting MATSim from Urbansim");	

		// checking if this is a test run
		// a test run only validates the xml config file by initializing the xml config via the xsd.
		isTestTun();

		// get the network. Always cleaning it seems a good idea since someone may have modified the input files manually in
		// order to implement policy measures.  Get network early so readXXX can check if links still exist.
		NetworkImpl network = (NetworkImpl) scenario.getNetwork();
		modifyNetwork(network);
		cleanNetwork(network);
		
		// get the data from urbansim (parcels and persons)
		ReadFromUrbansimParcelModel readFromUrbansim = new ReadFromUrbansimParcelModel( Integer.parseInt( scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.YEAR) ) );
		// read urbansim facilities (these are simply those entities that have the coordinates!)
		ActivityFacilitiesImpl parcels = new ActivityFacilitiesImpl("urbansim locations (gridcells _or_ parcels _or_ ...)");
		ActivityFacilitiesImpl zones   = new ActivityFacilitiesImpl("urbansim zones");
		// initializing parcels and zones from UrbanSim input
		readUrbansimParcelModel(readFromUrbansim, parcels, zones);
		
		// population generation
		int pc = benchmark.addMeasure("Population construction");
		Population newPopulation = readUrbansimPersons(readFromUrbansim, parcels, network);
		benchmark.stoppMeasurement(pc);
		System.out.println("Population construction took: " + benchmark.getDurationInSeconds( pc ) + " seconds.");
		Map<Id,WorkplaceObject> numberOfWorkplacesPerZone = ReadUrbansimJobs(readFromUrbansim);

		log.info("### DONE with demand generation from urbansim ###");

		// set population in scenario
		scenario.setPopulation(newPopulation);

		runControler(zones, parcels, numberOfWorkplacesPerZone, readFromUrbansim);
		
		if( scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.BACKUP_RUN_DATA_PARAM).equalsIgnoreCase("TRUE") ){
			// saving results from current run
			saveRunOutputs();			
			cleanUrbanSimOutput();
		}
		
	}
	
	void isTestTun(){
		if( scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.IS_TEST_RUN).equalsIgnoreCase(Constants.TRUE)){
			log.info("TestRun was successful...");
			return;
		}
	}
	
	/**
	 * read urbansim parcel table and build facilities and zones in MATSim
	 * 
	 * @param readFromUrbansim
	 * @param parcels
	 * @param zones
	 */
	void readUrbansimParcelModel(ReadFromUrbansimParcelModel readFromUrbansim, ActivityFacilitiesImpl parcels, ActivityFacilitiesImpl zones){
		readFromUrbansim.readFacilities(parcels, zones);
	}
	
	/**
	 * read person table from urbansim and build MATSim population
	 * 
	 * @param readFromUrbansim
	 * @param parcels
	 * @param network
	 * @return
	 */
	Population readUrbansimPersons(ReadFromUrbansimParcelModel readFromUrbansim, ActivityFacilitiesImpl parcels, NetworkImpl network){
		// read urbansim population (these are simply those entities that have the person, home and work ID)
		Population oldPopulation = null;
		if ( scenario.getConfig().plans().getInputFile() != null ) {
			
			String mode = scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.MATSIM_MODE);
			if(mode.equals(Constants.HOT_START))
				log.info("MATSim is running in HOT start mode, i.e. MATSim starts with pop file from previous run: " + scenario.getConfig().plans().getInputFile());
			else if(mode.equals(Constants.WARM_START))
				log.info("MATSim is running in WARM start mode, i.e. MATSim starts with pre-existing pop file:" + scenario.getConfig().plans().getInputFile());
			
			log.info("Persons not found in pop file are added; persons no longer in urbansim persons file are removed." ) ;
			
			oldPopulation = scenario.getPopulation() ;
			// log.info("Note that the `continuation of iterations' will only work if you set this up via different config files for") ;
			// log.info("every year and know what you are doing.") ;
		}
		else {
			log.warn("No population specified in matsim config file; assuming COLD start.");
			log.info("(I.e. generate new pop from urbansim files.)" );
			oldPopulation = null;
		}

		// read urbansim persons.  Generates hwh acts as side effect
		Population newPopulation = readFromUrbansim.readPersons( oldPopulation, parcels, network, Double.parseDouble( scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.SAMPLING_RATE)) ) ;
		
		// clean
		oldPopulation=null;
		System.gc();
		
		return newPopulation;
	}
	
	/**
	 * Reads in the job table from urbansim that contains for every "job_id" the corresponded "parcel_id_work" and "zone_id_work"
	 * and returns an HashMap with the number of job for each zone.
	 * 
	 * @return HashMap
	 */
	Map<Id,WorkplaceObject> ReadUrbansimJobs(ReadFromUrbansimParcelModel readFromUrbansim){
		return readFromUrbansim.readZoneBasedWorkplaces();
	}
	
	/**
	 * run simulation
	 * @param zones
	 */
	void runControler( ActivityFacilitiesImpl zones, ActivityFacilitiesImpl parcels, Map<Id,WorkplaceObject> numberOfWorkplacesPerZone, 
			ReadFromUrbansimParcelModel readFromUrbansim){
		
		Controler controler = new Controler(scenario);
		controler.setOverwriteFiles(true);	// sets, whether output files are overwritten
		controler.setCreateGraphs(false);	// sets, whether output Graphs are created
		
		// The following lines register what should be done _after_ the iterations were run:
		controler.addControlerListener( new Zone2ZoneImpedancesControlerListener( zones, parcels) ); 	// creates zone2zone impedance matrix
		controler.addControlerListener( new ZoneBasedAccessibilityControlerListener(zones, 				// creates zone based table of log sums (workplce accessibility)
																					readFromUrbansim.getAggregatedWorkplaces(parcels, 1., (NetworkImpl) scenario.getNetwork()), 
																					benchmark));
		
		// tnicolai todo?: count number of cars per h on a link
		// write ControlerListener that implements AfterMobsimListener (notifyAfterMobsim)
		// get VolumeLinkAnalyzer by "event.getControler.getVolume... and run getVolumesForLink. that returns an int array with the number of cars per hour on an specific link 
		// see also http://matsim.org/docs/controler
		
		// run the iterations, including the post-processing:
		controler.run() ;
	}
	
	/**
	 * cleaning matsim network
	 * @param network
	 */
	void cleanNetwork(NetworkImpl network){
		log.info("") ;
		log.info("Cleaning network ...");
		( new NetworkCleaner() ).run(network);
		log.info("... finished cleaning network.");
		log.info(""); 
	}
	
	/**
	 * This method allows to modify the MATSim network
	 * This needs to be implemented by another class
	 * 
	 * @param network
	 */
	void modifyNetwork(NetworkImpl network){
		// this is just a stub and does nothing. 
		// This needs to be implemented/overwritten by another class
	}
	
	/**
	 * loading, validating and initializing MATSim config.
	 */
	MatsimConfigType unmarschal(String matsimConfigFile){
		
		// JAXBUnmaschal reads the UrbanSim generated MATSim config, validates it against
		// the current xsd (checks e.g. the presents and data type of parameter) and generates
		// an Java object representing the config file.
		JAXBUnmaschal unmarschal = new JAXBUnmaschal( matsimConfigFile );
		
		MatsimConfigType matsimConfig = null;
		
		// binding the parameter from the MATSim Config into the JaxB data structure
		if( (matsimConfig = unmarschal.unmaschalMATSimConfig()) == null){
			
			log.error("Unmarschalling failed. SHUTDOWN MATSim!");
			System.exit(Constants.UNMARSCHALLING_FAILED);
		}
		return matsimConfig;
	}
	
	/**
	 * Saving UrbanSim and MATSim results for current run in a backup directory ...
	 */
	void saveRunOutputs() {
		log.info("Saving UrbanSim and MATSim outputs ...");
		
		String saveDirectory = "run" + scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.YEAR) + "-" + DateUtil.now();
		String savePath = Paths.checkPathEnding( Constants.MATSIM_4_OPUS_BACKUP + saveDirectory );
		FileCopy.copyTree(Constants.MATSIM_4_OPUS_TEMP, savePath);
		
		String newPlansFile = Constants.MATSIM_4_OPUS_OUTPUT + Constants.GENERATED_PLANS_FILE_NAME;
		String scorestatFile = Constants.MATSIM_4_OPUS_OUTPUT + Constants.SCORESTATS_FILE_NAME;
		String traveldistances = Constants.MATSIM_4_OPUS_OUTPUT + Constants.TRAVELDISTANCESSTAT_FILE_NAME;
		
		// get population / plans file
		try {
			FileCopy.fileCopy( new File(newPlansFile) , new File(savePath + Constants.GENERATED_PLANS_FILE_NAME) );
			FileCopy.fileCopy( new File(scorestatFile) , new File(savePath + Constants.SCORESTATS_FILE_NAME) );
			FileCopy.fileCopy( new File(traveldistances) , new File(savePath + Constants.TRAVELDISTANCESSTAT_FILE_NAME) );
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		log.info("Saving UrbanSim and MATSim outputs done!");
		
		String targetLocationHotStartFile = scenario.getConfig().getParam(Constants.MATSIM_4_URBANSIM_PARAM, Constants.TARGET_LOCATION_HOT_START_PLANS_FILE);
		if(!targetLocationHotStartFile.equals("")){
			
			log.info("Preparing hot start for next MATSim run ...");
			boolean success = FileCopy.moveFileOrDirectory(newPlansFile, targetLocationHotStartFile);
			if(success)
				log.info("Hot start preparation successful!");
			else
				log.error("Error while moving plans file, i. e. hot start will not work!");
		}
	}
	
	/**
	 * This is experimental
	 * Removes UrbanSim output files for MATSim, since they are 
	 * saved by performing saveRunOutputs() in a previous step.
	 */
	void cleanUrbanSimOutput(){
		
		log.info("Cleaning MATSim4Opus temp directory (" + Constants.MATSIM_4_OPUS_TEMP + ") from UrbanSim output." );
		
		ArrayList<File> fileNames = FileCopy.listAllFiles(new File(Constants.MATSIM_4_OPUS_TEMP), Boolean.FALSE);
		Iterator<File> fileNameIterator = fileNames.iterator();
		while(fileNameIterator.hasNext()){
			File f = fileNameIterator.next();
			try {
				if(f.getCanonicalPath().endsWith(".tab") || f.getCanonicalPath().endsWith(".meta")){
					log.info("Removing " + f.getCanonicalPath());
					f.delete();
				}
			} catch (IOException e) {
				e.printStackTrace();
				log.info("While removing UrbanSim output an IO error occured. This is not critical.");
			}
		}
		log.info("... done!");
	}
	
	/**
	 * Entry point
	 * @param args urbansim command prompt
	 */
	public static void main(String args[]){
		MATSim4UrbanSim m4u = new MATSim4UrbanSim(args);
		m4u.runMATSim();
		MATSim4UrbanSim.isSuccessfulMATSimRun = Boolean.TRUE;
	}
	
	/**
	 * this method is only called/needed by "matsim4opus.matsim.MATSim4UrbanSimTest"
	 * @return true if run was successful
	 */
	public static boolean getRunStatus(){
		return MATSim4UrbanSim.isSuccessfulMATSimRun;
	}
}



