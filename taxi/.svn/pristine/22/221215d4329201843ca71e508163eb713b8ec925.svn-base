\documentclass{book}

\usepackage[sf]{titlesec}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{soul}

\parindent0pt
\parskip0.3\baselineskip

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Intro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Creating and Destroying Objects}

\chapter{Consider providing static factory methods instead of c'tors}

Aus meiner Sicht ist das klar: Sobald wir erreichen wollen, dass
andere das Interface statt der Implementation verwenden, sollten wir
``factory methods'' einsetzen, welche das Interface zurückgeben.

\chapter{Enforce the singleton property with a private c'tor}

klar

\chapter{Enforce noninstantiability with a private c'tor}

Geht eigentlich darum, dass es ein ``namespace'' ist (nur statische
Methoden) und keine Klasse.

\chapter{Avoid creating duplicate objects}

C'tors erzeugen immer neue Objekte, static factory methods nicht
notwendigerweise. 

Sehe nicht, wo das bei uns eine große Rolle spielt.

\chapter{Eliminate obsolete object references}

null out references once they become obsolete

\chapter{Avoid finalizers}

ok

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Methods common to all objects}

\chapter{Obey the general contract when overriding {\tt equals}}

Im Detail nicht so einfach, wenn Objekte in Hierarchien verglichen
werden, weil nicht immer sofort klar ist, auf welcher Ebene verglichen
wird. 

\chapter{Always override {\tt hashCode} when you override {\tt
    equals}}

Ansonsten kann es (natürlich) passieren, dass Objekte, die laut {\tt
  equals} gleich sind, unterschiedlichen hash code haben.  

\chapter{Always override {\tt toString}}

ok

\chapter{Override {\tt clode} judiciously}

M.E.: nicht benutzen

\chapter{Consider implementing {\tt Comparable}}

ok, da haben wir m.E.\ genug Übung

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Classes and Interfaces}

\chapter{Minimize the accessibility of classes and members}

\chapter{Design and document for inheritance or else prohibit it}

Design for inheritance:
\begin{itemize}

\item document precisely the effects of overriding any method

\item provide hooks into the internal workings of the class

\item c'tors must not invoke overridable methods

\item the class should not be \verb$Serializable$ or \verb$Cloneable$

\item (eliminate the class's self-use of overridable methods entirely)

\end{itemize}

Ways to prohibit subclassing:
\begin{itemize}

\item make the class final

\item make all c'tors private or package-private (and provide factory
  methods for access)

\end{itemize}

\end{document}


